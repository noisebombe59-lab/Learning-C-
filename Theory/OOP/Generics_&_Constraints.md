1. Синтаксис Обобщений (Generics)
Суть в том, что мы не пишем конкретный тип (например, int), а используем параметр типа (обычно букву T).

Обобщенный класс: Позволяет хранить данные любого типа.

C#
public class Box<T> 
{
    private T _content;
    public void Store(T item) => _content = item;
    public T Retrieve() => _content;
}
Обобщенный метод: Позволяет методу работать с разными типами, даже если сам класс не является обобщенным.

C#
public void PrintInfo<T>(T item) 
{
    Console.WriteLine($"Тип: {typeof(T)}, Значение: {item}");
}
2. Базовые ограничения (where T : ...)
Без ограничений компилятор считает, что T — это просто какой-то object. Ты не можешь создать его через new или вызвать у него специфические методы. Ограничения говорят: "Я разрешаю подставлять вместо T только те типы, которые..."

where T : class: Только ссылочные типы. Теперь ты можешь присвоить T = null.

where T : struct: Только значимые типы (числа, структуры).

where T : new(): У типа обязан быть пустой конструктор. Это дает тебе право писать T item = new T(); внутри кода.

where T : ИмяИнтерфейса: Самое полезное. Ты обещаешь, что у любого T будет метод из этого интерфейса.

3. Множественные ограничения
Если тебе нужно, чтобы тип был и классом, и имел конструктор, и реализовывал интерфейс — перечисляй их через запятую.

Правила порядка:

Первым — class, struct или базовый класс.

Вторыми — интерфейсы.

Последним — обязательно new().

C#
// Правильно:
public class Processor<T> where T : class, ICloneable, new() 
{
    public T CloneNew() => new T(); // Работает благодаря new()
}
4. Работа с default
Внутри обобщенного кода ты не знаешь, что такое "пусто". Если T это int, то "пусто" — это 0. Если T это класс — это null. Ключевое слово default само подбирает нужное значение.

C#
public T GetDefaultValue<T>()
{
    return default(T); // Или просто return default;
}

// Вызов:
int x = GetDefaultValue<int>(); // вернет 0
string s = GetDefaultValue<string>(); // вернет null