Полиморфизм (Virtual / Override / Casting)

1. Механика "Virtual & Override" — Связь "Гибкое поведение"

Суть: Позволяет базовому классу определить «стандартное» поведение, а наследникам — адаптировать его под свои нужды, сохраняя единый интерфейс вызова.

Virtual Method: Декларация в родителе. Это «разрешение на тюнинг». Класс говорит: «Я умею это делать так, но ты можешь лучше».

Override Method: Реализация в наследнике. Это «новая прошивка». Класс говорит: «Я заменяю стандартный алгоритм своим».

Синтаксис: Ключевые слова virtual (в родителе) и override (в наследнике).

Пример синтаксиса:

    C#
    public class Logger 
    {
        // Виртуальный метод - есть базовая логика
        public virtual void Log(string message) 
        {
            Console.WriteLine($"[LOG]: {message}");
        }
    }
    
    public class FileLogger : Logger 
    {
        public override void Log(string message) 
        {
            // base.Log(message); // Можно вызвать и родителя, если нужно
            // Но здесь мы полностью меняем поведение на запись в файл (условно)
            System.IO.File.AppendAllText("log.txt", message);
        }
    }
2. Приведение типов (Casting) — "Смена фокуса"

Суть: Возможность смотреть на сложный объект (Manager) через призму его базовой роли (Employee).

Upcasting (Вверх): Переход от наследника к родителю. Происходит автоматически. Мы «забываем» о деталях и видим только общие черты.

Downcasting (Вниз): Переход от родителя к наследнику. Это риск. Мы пытаемся восстановить детали, которых может и не быть.

Инструменты безопасности (is / as):

is (Pattern Matching): Проверка + создание переменной. «Если это Прямоугольник — назови его rect и работай».

as (Safe Cast): Попытка приведения. «Попробуй сделать его Прямоугольником, если не выйдет — дай мне null».

3. Скрытие метода (New) — "Обрыв связи"

Суть: Создание метода с тем же именем, который не участвует в полиморфизме. Это не переопределение, а «перекрытие».

Разница: * Если метод override — программа вызовет логику наследника, даже если переменная типа «Родитель».

Если метод new — программа вызовет метод того типа, который указан у переменной.

Важно: В нормальной разработке new используется крайне редко (обычно для совместимости со старым кодом). Для Junior-задач всегда выбирай override.

Золотые правила 10-й недели
Принцип "Единого пульта": Используй полиморфизм, чтобы управлять целым списком разных объектов одной командой.

Пример: У тебя List<Shape>, и ты просто вызываешь .Draw() у всех в цикле. Тебе не важно, кто там — круг или квадрат. Каждый «нарисует» себя сам правильно.

Защита через is: Никогда не делай жесткое приведение типа (Circle)shape, если не уверен на 100%. Всегда используй if (shape is Circle c). Это предотвратит падение программы.

Не ломай ожидания: Если ты переопределяешь метод (override), он должен делать то же самое по смыслу, что и в родителе.

Плохо: Метод CalculateArea() у наследника вдруг начинает отправлять Email.

Хорошо: Метод CalculateArea() просто считает площадь по другой формуле.

Скука — это сигнал: Если ты понимаешь, что override просто подменяет метод, а is просто проверяет тип — значит, база усвоена. Можно переходить к практике.
