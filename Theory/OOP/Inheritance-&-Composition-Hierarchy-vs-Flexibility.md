Наследование и Композиция
1. Наследование (Inheritance) — Связь "Is-a" (Является)
Механизм, позволяющий создать новый класс на основе существующего, перенимая его поля и методы.

Базовый класс (Parent): Общая логика (например, User).

Производный класс (Child): Специфическая логика (например, Admin).

Синтаксис: Используется двоеточие : для наследования и base() для обращения к родителю.

Пример синтаксиса:

    C#
    
    public class User 
    {
        private string _login;
        public User(string login) 
        {
            if (string.IsNullOrWhiteSpace(login)) throw new Exception("Empty login");
            _login = login;
        }
    }
    
    public class Admin : User 
    {
        private int _level;
        // base(login) пробрасывает данные в конструктор User
        public Admin(string login, int level) : base(login) 
        {
            _level = level;
        }
    }
2. Абстрактные классы и методы (Abstract)
Инструмент для создания «чертежей», которые нельзя воплотить в объект напрямую.

Abstract Class: Класс-заготовка. Нельзя сделать new Employee().

Abstract Method: Метод без реализации (без {}). Обязывает всех наследников написать свою логику.

Синтаксис: Ключевые слова abstract (в родителе) и override (в наследнике).

Пример синтаксиса:

    C#
    
    public abstract class Weapon 
    {
        public abstract void Fire(); // Нет тела метода
    }
    
    public class Pistol : Weapon 
    {
        public override void Fire() // Обязательная реализация
        {
            Console.WriteLine("Pistol shot!");
        }
    }
3. Композиция (Composition) — Связь "Has-a" (Содержит)
Создание сложного объекта путем включения в него других объектов как полей.

Зачем: Это гибче наследования. Мы собираем объект из «деталей».

Синтаксис: Просто объявление поля другого типа внутри класса.

Пример синтаксиса:

    C#
    
    public class Battery { public int Charge = 100; }
    
    public class Flashlight 
    {
        private readonly Battery _battery; // Композиция: Фонарик ИМЕЕТ батарейку
    
        public Flashlight(Battery battery) 
        {
            _battery = battery ?? throw new ArgumentNullException();
        }
    }
Правила качественного проектирования
Liskov Substitution (Принцип подстановки): Наследник должен полностью заменять родителя. 
Если метод принимает Vehicle, он должен работать и с Car, и с Truck, не ломаясь.

Предпочитай композицию наследованию: Наследование — это «жесткая» связь. 
Если класс Б просто использует функции класса А, делай композицию. Если Б является версией А — делай наследование.

Защита в base: Конструктор абстрактного класса должен иметь protected доступ и проверять данные. 
Наследник не имеет права «подсунуть» родителю невалидные данные через base().

1. Наследование (Inheritance) — Связь "Is-a"
Суть: Создание узконаправленной, стабильной ветки на базе общей идеи.

Синтаксис: Используем :, чтобы связать классы.

Конструктор (base): Используется для активации родителя и проброса данных «наверх» для централизованной валидации. 
Это защищает от дублирования проверок в каждом наследнике.

Когда выбирать: Только если объект на 100% является разновидностью родителя и эта связь не изменится.

2. Абстракция (Abstract) — "Чертеж и Метка"
Абстрактный класс: Нельзя создать через new. Это «защита от недоделок».

Абстрактный метод: Не имеет тела (реализации). Это «жесткая метка» и обязанность для наследника реализовать логику.

Синтаксис (override): Используется перед методом в наследнике, чтобы реализовать («исполнить») обещание, данное в абстрактном классе.

Суть: Позволяет держать фокус на том, что объект должен делать, не отвлекаясь на детали как он это делает.

3. Композиция (Composition) — Связь "Has-a"
Суть: Сборка объекта из деталей (детали — это поля других типов внутри класса).

Когда выбирать: Если нет уверенности в векторе развития или если объект просто «использует» функции другого, а не является его версией.

Плюс: Максимальная гибкость — детали (компоненты) можно менять, не ломая ДНК всего класса.

4. Золотые правила проектирования
Защита в родителе: Всю общую валидацию (проверку на null, отрицательные числа и т.д.) пишем в конструкторе базового класса один раз.
Наследники просто пользуются этой защитой через base.

Локальность: Наследование лучше держать «коротким» (1-2 уровня). Если иерархия разрастается — переходи на композицию.

Liskov (LSP): Наследник никогда не должен ломать ожидания от родителя. Программа должна работать с Admin так же стабильно, как с User.
