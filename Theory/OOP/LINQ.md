1. Декларативный стиль → (Declarative Programming)
Это противопоставление Императивному стилю.

Императивный (Как делать): Создай пустой список, запусти цикл for, проверь условие if, добавь элемент в список.

Декларативный (Что получить): «Дай мне всех активных пользователей».

В теории: Это делает код более читаемым и менее подверженным ошибкам "off-by-one" (ошибка на единицу в циклах).

2. Deferred Execution → (Отложенное или «Ленивое» выполнение)
Это одна из самых важных тем в LINQ.

Итераторы и yield return: В основе этого механизма лежит ключевое слово yield. Когда вы вызываете .Where(), создается объект-итератор, который «ждет» команды начать работу.

Построение дерева выражений (Expression Trees): Для вашей 14-й недели это ключевой момент. В LINQ to Objects это просто цепочка делегатов, а в LINQ to Entities (EF) — это структура данных, которую провайдер базы данных потом переведет в SQL.

Зачем это нужно: Для экономии памяти и производительности. Зачем фильтровать миллион записей сразу, если вам в итоге нужны только первые 10?

3. IEnumerable<T> → (Интерфейсы перечисления)
Это относится к теме «Обобщения (Generics) и паттерн Итератор».

Абстракция данных: IEnumerable<T> — это «контракт», который обещает, что по этой коллекции можно пройтись циклом foreach.

Благодаря этому LINQ — это методы расширения (Extension Methods). Они «приклеиваются» к любому объекту, который реализует этот интерфейс.

2. Основные методы с примерами
Представь задачу: у нас есть список товаров List<Product> products. У каждого есть Name, Price, Category и Stock (количество).

Фильтрация: Where
Оставляет только те элементы, которые прошли проверку.

    C#
    // Находим товары, которые стоят дешевле 1000 и они есть в наличии
    var cheapInStock = products.Where(p => p.Price < 1000 && p.Stock > 0);
    
Проекция (Трансформация): Select
Меняет тип данных. Например, превращает объект «Товар» в строку «Название».

    C#
    // Получаем только список названий всех товаров для вывода в меню
    var productNames = products.Select(p => p.Name);
    
Поиск одного: First / FirstOrDefault / Single
First: Дай первый элемент. (Упадет, если список пуст).

FirstOrDefault: Дай первый или null. (Безопасно).

Single: Дай единственный. (Упадет, если товаров с таким именем два).

    C#
    // Ищем товар по точному артикулу. Если не нашли — получим null, программа не упадет.
    var item = products.FirstOrDefault(p => p.Id == 505);
    
Наличие: Any
Быстрая проверка «есть ли там хоть что-то». Возвращает только true или false.

    C#
    // Проверяем, есть ли в магазине хоть один товар из категории "Электроника"
    bool hasTech = products.Any(p => p.Category == "Electronics");
    
1. Первичная сортировка (Всегда первая в цепочке)
OrderBy: Сортирует по возрастанию (1 $\to$ 10, А $\to$ Я).
OrderByDescending: Сортирует по убыванию (10 $\to$ 1, Я $\to$ А).

3. Вторичная сортировка (Только после первичной)
Используется, если у нескольких элементов совпало значение первого критерия.
ThenBy: Дополнительная сортировка по возрастанию.
ThenByDescending: Дополнительная сортировка по убыванию.

Примеры кода
Простой список:
        
        C#
        var prices = new List<int> { 100, 500, 200, 50 };
        var sorted = prices.OrderByDescending(p => p); // 500, 200, 100, 50
        
Сложный объект (Товары):
        
        C#
        // Сначала по категории (А-Я), затем внутри категории по цене (дорогие первые)
        var result = products
            .OrderBy(p => p.Category)
            .ThenByDescending(p => p.Price);
    
Агрегация: Count / Sum / Max
Превращает всю коллекцию в одно число.
    
    C#
    // Считаем общую стоимость всех товаров на складе (цена * количество)
    var totalValue = products.Sum(p => p.Price * p.Stock);
    
    // Узнаем цену самого дорогого товара
    var maxPrice = products.Max(p => p.Price);
    
3. «Ловушки» для Junior-разработчика
Замыкание (Closure) в цикле
Лямбда «запоминает» переменную, а не её значение в моменте.

        C#
        var filters = new List<Func<int, bool>>();
        for (int i = 0; i < 3; i++) 
        {
            // ОШИБКА: Все фильтры будут использовать последнее значение i (которое станет 3)
            filters.Add(x => x > i); 
        }
Лишний ToList()
Не вызывай его в середине цепочки. Это заставляет компьютер создавать промежуточную копию данных в памяти. Используй его только в самом конце, когда результат нужно сохранить.

   Кванторы в LINQ — это методы, которые проверяют, соответствует ли коллекция какому-то правилу. В отличие от Where или Select, они всегда возвращают только булево значение (true или false).

1. Метод .Any() (Есть ли хоть один?)
Этот метод — самый «ленивый» и быстрый. Он сканирует список до тех пор, пока не найдет первое совпадение. Как только нашел — сразу кричит «Да!» (true) и прекращает работу.

Зачем нужен: Проверить наличие дефицита, ошибок или просто узнать, не пустой ли список.

    Пример: bool hasDebt = clients.Any(c => c.Balance < 0);

Лайфхак: Вызов .Any() без условий просто скажет, есть ли в списке хоть один элемент. Это быстрее, чем проверять .Count() > 0.

2. Метод .All() (Все ли соответствуют?)
Этот метод — строгий контролер. Он вернет true только в том случае, если абсолютно каждый элемент в коллекции прошел проверку. Если хотя бы один «провинился», результат будет false.

Зачем нужен: Валидация. Проверить, что у всех товаров есть описание, или что все цены положительные.

    Пример: bool allDelivered = orders.All(o => o.Status == "Delivered");

3. Метод .Contains() (Есть ли конкретно этот?)
Работает проще: проверяет, содержится ли в коллекции конкретный объект или значение.

        Пример: bool hasMilk = productNames.Contains("Milk");

   Пагинация — это техника разделения большого набора данных на мелкие части (страницы).
   В LINQ это реализуется через два метода расширения интерфейса IEnumerable.

еория: Skip и Take
Эти методы управляют количеством и позицией выбираемых данных.

Skip(n) — пропускает первые n элементов и возвращает все остальные.

Take(n) — забирает первые n элементов и игнорирует остальные.

Важные правила:

Если Skip больше, чем элементов в списке — вернется пустой результат (ошибки не будет).

Если Take больше, чем осталось элементов — вернется всё, что удалось взять.

    пример
    C#
    var data = new[] { "A", "B", "C", "D", "E" };
    
    // 1. Пропустить первые 2
    var skipOnly = data.Skip(2); // { "C", "D", "E" }
    
    // 2. Взять первые 3
    var takeOnly = data.Take(3); // { "A", "B", "C" }
    
    // 3. Пагинация (Пропустить 1, Взять 2)
    var page = data.Skip(1).Take(2); // { "B", "C" }
