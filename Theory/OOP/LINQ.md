1. Декларативный стиль → (Declarative Programming)
Это противопоставление Императивному стилю.

Императивный (Как делать): Создай пустой список, запусти цикл for, проверь условие if, добавь элемент в список.

Декларативный (Что получить): «Дай мне всех активных пользователей».

В теории: Это делает код более читаемым и менее подверженным ошибкам "off-by-one" (ошибка на единицу в циклах).

2. Deferred Execution → (Отложенное или «Ленивое» выполнение)
Это одна из самых важных тем в LINQ.

Итераторы и yield return: В основе этого механизма лежит ключевое слово yield. Когда вы вызываете .Where(), создается объект-итератор, который «ждет» команды начать работу.

Построение дерева выражений (Expression Trees): Для вашей 14-й недели это ключевой момент. В LINQ to Objects это просто цепочка делегатов, а в LINQ to Entities (EF) — это структура данных, которую провайдер базы данных потом переведет в SQL.

Зачем это нужно: Для экономии памяти и производительности. Зачем фильтровать миллион записей сразу, если вам в итоге нужны только первые 10?

3. IEnumerable<T> → (Интерфейсы перечисления)
Это относится к теме «Обобщения (Generics) и паттерн Итератор».

Абстракция данных: IEnumerable<T> — это «контракт», который обещает, что по этой коллекции можно пройтись циклом foreach.

Благодаря этому LINQ — это методы расширения (Extension Methods). Они «приклеиваются» к любому объекту, который реализует этот интерфейс.

2. Основные методы с примерами
Представь задачу: у нас есть список товаров List<Product> products. У каждого есть Name, Price, Category и Stock (количество).

Фильтрация: Where
Оставляет только те элементы, которые прошли проверку.

    C#
    // Находим товары, которые стоят дешевле 1000 и они есть в наличии
    var cheapInStock = products.Where(p => p.Price < 1000 && p.Stock > 0);
    
Проекция (Трансформация): Select
Меняет тип данных. Например, превращает объект «Товар» в строку «Название».

    C#
    // Получаем только список названий всех товаров для вывода в меню
    var productNames = products.Select(p => p.Name);
    
Поиск одного: First / FirstOrDefault / Single
First: Дай первый элемент. (Упадет, если список пуст).

FirstOrDefault: Дай первый или null. (Безопасно).

Single: Дай единственный. (Упадет, если товаров с таким именем два).

    C#
    // Ищем товар по точному артикулу. Если не нашли — получим null, программа не упадет.
    var item = products.FirstOrDefault(p => p.Id == 505);
    
Наличие: Any
Быстрая проверка «есть ли там хоть что-то». Возвращает только true или false.

    C#
    // Проверяем, есть ли в магазине хоть один товар из категории "Электроника"
    bool hasTech = products.Any(p => p.Category == "Electronics");
    
1. Первичная сортировка (Всегда первая в цепочке)
OrderBy: Сортирует по возрастанию (1 $\to$ 10, А $\to$ Я).
OrderByDescending: Сортирует по убыванию (10 $\to$ 1, Я $\to$ А).

3. Вторичная сортировка (Только после первичной)
Используется, если у нескольких элементов совпало значение первого критерия.
ThenBy: Дополнительная сортировка по возрастанию.
ThenByDescending: Дополнительная сортировка по убыванию.

Примеры кода
Простой список:
        
        C#
        var prices = new List<int> { 100, 500, 200, 50 };
        var sorted = prices.OrderByDescending(p => p); // 500, 200, 100, 50
        
Сложный объект (Товары):
        
        C#
        // Сначала по категории (А-Я), затем внутри категории по цене (дорогие первые)
        var result = products
            .OrderBy(p => p.Category)
            .ThenByDescending(p => p.Price);
    
Агрегация: Count / Sum / Max
Превращает всю коллекцию в одно число.
    
    C#
    // Считаем общую стоимость всех товаров на складе (цена * количество)
    var totalValue = products.Sum(p => p.Price * p.Stock);
    
    // Узнаем цену самого дорогого товара
    var maxPrice = products.Max(p => p.Price);
    
3. «Ловушки» для Junior-разработчика
Замыкание (Closure) в цикле
Лямбда «запоминает» переменную, а не её значение в моменте.

        C#
        var filters = new List<Func<int, bool>>();
        for (int i = 0; i < 3; i++) 
        {
            // ОШИБКА: Все фильтры будут использовать последнее значение i (которое станет 3)
            filters.Add(x => x > i); 
        }
Лишний ToList()
Не вызывай его в середине цепочки. Это заставляет компьютер создавать промежуточную копию данных в памяти. Используй его только в самом конце, когда результат нужно сохранить.
