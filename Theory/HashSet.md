HashSet<T> в C# — Полная шпаргалка 2025 (для middle и выше)
──────────────────────────────────────────────────────────────────────
ЧТО ЭТО И ЗАЧЕМ НУЖЕН
──────────────────────────────────────────────────────────────────────
HashSet<T> — коллекция УНИКАЛЬНЫХ элементов с молниеносным доступом
⊳ Нет дубликатов (автоматически отбрасывает повторы)
⊳ Add / Contains / Remove — O(1) в среднем (очень быстро)
⊳ Не сохраняет порядок добавления
⊳ Под капотом — хеш-таблица (как Dictionary, но только с ключами)

──────────────────────────────────────────────────────────────────────
ПОДКЛЮЧАЕМЫЕ ПРОСТРАНСТВА ИМЁН
──────────────────────────────────────────────────────────────────────
using System.Collections.Generic;     // обязательно
using System.Linq;                    // для ToHashSet() и др.

──────────────────────────────────────────────────────────────────────
СОЗДАНИЕ И ИНИЦИАЛИЗАЦИЯ
──────────────────────────────────────────────────────────────────────
    var set = new HashSet<string>();
    
    // C# 9+ — красивый синтаксис
    var banned = new HashSet<string> { "127.0.0.1", "192.168.1.1" };
    
    // Из любого IEnumerable (самый частый кейс!)
    var uniqueIds = new HashSet<int>(largeListOfIds);
    // или ещё короче (.NET 6+)
    var uniqueNames = namesList.ToHashSet();

──────────────────────────────────────────────────────────────────────
ОСНОВНЫЕ ОПЕРАЦИИ (ЭТО СПРАШИВАЮТ НА СОБЕСЕ!)
──────────────────────────────────────────────────────────────────────
set.Add("admin");                    // возвращает bool: true = добавлен, false = уже был
bool exists = set.Contains("admin"); // O(1) — мгновенно
set.Remove("admin");                 // возвращает bool
set.Clear();                         // полностью очистить
int count = set.Count;

──────────────────────────────────────────────────────────────────────
МГНОВЕННАЯ ФИЛЬТРАЦИЯ ДУБЛЕЙ (классика интервью)
──────────────────────────────────────────────────────────────────────
// Было: List<string> с 10 млн элементов и кучей дублей
var duplicatesRemoved = rawData.ToHashSet();           // → 1 строка, O(n)
// Или если нужен List обратно:
var cleanList = rawData.ToHashSet().ToList();

──────────────────────────────────────────────────────────────────────
ОПЕРАЦИИ НАД МНОЖЕСТВАМИ (Set Operations) — ОЧЕНЬ ЛЮБЯТ НА СОБЕСАХ
──────────────────────────────────────────────────────────────────────
    setA.UnionWith(setB);              // объединение (всё вместе)
    setA.IntersectWith(setB);          // пересечение (только общее)
    setA.ExceptWith(setB);             // разность (убрать всё, что есть в B)
    setA.SymmetricExceptWith(setB);    // XOR: только в одном из наборов
    
    // Проверки
    setA.IsSubsetOf(setB);             // A полностью внутри B?
    setA.IsSupersetOf(setB);           // A содержит всё из B?
    setA.Overlaps(setB);               // есть хоть один общий элемент?
    setA.SetEquals(setB);              // множества полностью одинаковы?
    
    // Удаление по условию
    set.RemoveWhere(x => x.StartsWith("temp_"));

──────────────────────────────────────────────────────────────────────
КРИТИЧЕСКИ ВАЖНО: ПРАВИЛЬНЫЕ КЛЮЧИ!
──────────────────────────────────────────────────────────────────────
    // Плохо (по ссылке):
    class User { public string Name; }
    var set = new HashSet<User>();     // каждый new User — уникален!
    
    // Хорошо:
    class User : IEquatable<User>
    {
        public string Name { get; set; }
        public override bool Equals(object? obj) => obj is User u && u.Name == Name;
        public override int GetHashCode() => Name?.GetHashCode() ?? 0;
        public bool Equals(User? other) => other?.Name == Name;
    }
    
    // Или ещё лучше — record (автоматом всё переопределяет)
    record User(string Name);

──────────────────────────────────────────────────────────────────────
ЗОЛОТЫЕ ПРАВИЛА (обязательно знать на собеседовании)
──────────────────────────────────────────────────────────────────────
1. НИКОГДА не используй изменяемые объекты как элементы без переопределения Equals/GetHashCode
2. Если нужен порядок — бери SortedSet<T> или List<T>
3. Contains — O(1), не делай list.Contains() в циклах по миллиону!
4. ToHashSet() — твой лучший друг при очистке от дублей
5. Для игнорирования регистра строк:
   var set = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

──────────────────────────────────────────────────────────────────────
МИНИ-ШПАРГАЛКА (держи всегда под рукой)
──────────────────────────────────────────────────────────────────────
var set = new HashSet<string>(StringComparer.CurrentCultureIgnoreCase);
set.Add("test");                                // bool
set.Contains("TEST") → true
set.RemoveWhere(x => x.Length > 10);
var unique = bigList.ToHashSet();
admins.UnionWith(moderators);
blocked.ExceptWith(whitelist);
foreach (var ip in banned) { }                  // порядок НЕ гарантирован

Готово! Теперь ты на 100% готов отвечать про HashSet<T> на любом уровне — от junior до senior.
Копируй → вставляй → пиши код как профи
